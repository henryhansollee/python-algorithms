# 가장 먼 노드

###### 나의 풀이

```python
from collections import deque

def solution(n, edge):
    graph = {}
    visited = [0] * n
    for e in edge:
        graph[e[0]] = graph.get(e[0], []) + [e[1]]
        graph[e[1]] = graph.get(e[1], []) + [e[0]]
    queue = deque()
    queue.append(1)
    visited[0] = 1
    while queue:
        nodes = len(queue)
        for _ in range(nodes):
            curr = queue.popleft()
            for c in graph[curr]:
                if visited[c-1] == 0:
                    visited[c-1] = 1
                    queue.append(c)
    return nodes
```

###### 다른 풀이

```python
def solution(n, edge):
    graph =[  [] for _ in range(n + 1) ]
    distances = [ 0 for _ in range(n) ]
    is_visit = [False for _ in range(n)]
    queue = [0]
    is_visit[0] = True
    for (a, b) in edge:
        graph[a-1].append(b-1)
        graph[b-1].append(a-1)

    while queue:
        i = queue.pop(0)

        for j in graph[i]:
            if is_visit[j] == False:
                is_visit[j] = True
                queue.append(j)
                distances[j] = distances[i] + 1

    distances.sort(reverse=True)
    answer = distances.count(distances[0])

    return answer

```

